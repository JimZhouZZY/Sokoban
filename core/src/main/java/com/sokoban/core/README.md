`Sokoban` 逻辑后端

# 关于 `Sokoban` 游戏的一些说明

## 新增相关说明

#### 12.1

***设计思路已经产生较大改动，请详见各个文档的说明***

***此文档仅在不冲突的情况下作为底本参阅***

---

#### 11.19

1. 物块映射到整数有多种可能，这时候只需要随意映射到一个整数即可
2. 定义一个物体类，物体类有以下必需字段：
    - `ObjectType type` - 表示物体的类型
    - `int x, y` - 表示物体在地图中的位置
3. 推荐为物体类添加各种 getter 和 setter，以及类似于 moveUp, moveDown 等方法，这样有助于写逻辑判断代码的时候阅读与检查
4. 在创建地图类的时候，可以使用有关物体类的二维数组，这样就可以表示一个地图

## 有关常量映射与储存的示例代码

在同目录的 `ReadSomeThing.java` 中

## 整数地图文件储存

地图文件本质作为一个**文本文件**，可以命名为 `modeName-levelName.map`，例如 `3-2.map` 和 `Origin-Addition.map`

其中，`modeName` 代表游戏的模式名称，`levelName` 代表当前模式的关卡名称

读取地图的时候可以直接把地图文件名写在代码中，最好写成**常量枚举类**（见后文）以便代码中调用

## 整数地图内容格式

地图文件本身可以有多个子地图，用于实现游戏的不同机制。

总的来说，地图文件应该有以下内容：

1. 一个一行的字符串，可以用作这个地图的一些**附加内容**（例如标题等），没有附加信息就填入**字符串** none
2. 子地图的**总数量**
3. 当前子地图的**长**和**宽**
4. 当前子地图的地**图内容**
5. 分割不同子地图的**分隔符**

举例如下：

```
some description
1
7 9
1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 1 0
1 0 0 0 0 0 1 0 0
1 0 0 0 0 1 0 0 0
1 1 1 0 0 0 1 0 0
1 0 0 0 0 0 0 1 0
1 0 0 0 0 0 0 0 1
```

以上地图文件按顺序表示：

 - 地图文件的附加内容是“some description”
 - 文件中含有 1 个子地图
 - 第一个子地图有 7 行 9 列
 - 第一个子地图的二维整数数组数据

```
none
2
4 4
1 1 1 1
1 0 0 1
1 49 1 1
1 0 1 1
-
3 6
1 1 2 1 1 1
1 0 0 0 0 0
1 1 1 1 1 1
```

以上地图文件按顺序表示：

 - 地图文件没有附加内容
 - 文件中含有 2 个子地图
 - 第一个子地图有 4 行 4 列
 - 第一个子地图的二维整数数组数据
 - 第二个子地图有 3 行 6 列
 - 第二个子地图的二维整数数组数据

#### 一些注意的地方

1. 地图文件读取是**先行后列**，这一点很容易搞混
2. 左上角**第一个**整数的位置为 `(0, 0)`，也就是原点，右下角**最后一个**整数位置是 `(行数 - 1, 列数 - 1)`
3. 地图必须是矩形，如果有异性地图，需要把外围不足的部分填充为空气后存储

## 整数地图映射说明

地图文件中的不同整数将会被映射为功能不同的块，以供逻辑编写使用

以下是映射：

`0` - 代表空气，任何物块都可以因为移动占据这个位置

`1 ~ 9` - 代表墙，暂时还没有不同功能的划分，在处理的时候可以统一映射成墙，后期有需要再修改

`10 ~ 19` - 代表玩家，目前不同状态的划分有：

 - `10` - 代表普通玩家
 - `11` - 代表走到了箱子目标点的玩家
 - `12` - 代表走到了玩家目标点的玩家，在一些关卡中，不仅要求箱子被推到箱子目标点，还需要玩家到达玩家目标点才会判定胜利
 - `13 ~ 19` - 暂时没有划分，统一映射为普通玩家

`20 ~ 29` - 代表箱子，目前不同状态的划分有：

 - `20` - 代表普通箱子
 - `21` - 代表一个被推到“玩家目标点”的箱子
 - `22 ~ 29` - 暂时没有划分，统一映射为普通箱子

`30 ~ 39` - 代表目标点，目前划分有：

 - `30` - 代表普通箱子目标点，普通箱子移动到这里是胜利必要条件
 - `31` - 代表玩家目标点，如果存在玩家目标点，则玩家移动到这里是胜利必要条件
 - `32 ~ 39` - 代表已经占据了一个箱子的目标点，暂时没有划分，统一映射为已经有箱子的普通目标点

`>= 40` - 暂时没有代表物，可以先不处理

#### 一些注意的地方

1. 为什么要划分类似于“普通玩家”和“走到了目标点玩家”这种看似重复的类型呢？Foe example，普通玩家走到另一格空气的时候，原先那一格会变成空气；然而对于“走到箱子目标点的玩家”，如果他走到另一格空气，原先那一格会变成普通的箱子目标点
2. 这个实现起来看起来有一些繁琐，实际上是为了一些后期功能考虑的，需要预留一些位置
3. 映射到的具体常量可以按照功能进行命名，例如 `31` 可以命名为 `PlayerTarget`，常量枚举类的定义和映射方式见末尾

## 具体逻辑的一些说明

总的来说基础内容和普通推箱子差不多，有几条规则可以注意一下：

1. 箱子叠在一起也可以一次推动
2. ...

## 关于 Java 类文件的一些说明

这里相当于是前端和后端衔接的一些要求

实现的核心逻辑类可以拆分多个方法和类，如果写在一个文件中会比较臃肿，最好是能做到每个方法行数 <= 20（不硬性要求）

衔接前后端的类应当有一些重要方法（建议实现，方法名字可以不同，表现方法作用即可，后续可能还会有新的需求）：

1. `moveUp` `moveDown` `moveLeft` `moveRight` - 用户在按下按键的时候，前端会调用这些方法，这时候后端应该**处理玩家的移动逻辑**：产生了什么移动？移动后地图的变化如何？这个移动是否会让游戏结束？诸如此类
2. `getCurrentMapContent` - 前端调用这个方法以获取**现在地图的状态**，因为前端不会负责处理移动逻辑，它只能靠读取地图的变化来生成相应的动画，所以后端需要将地图传递给前端
3. `isGameSuccess` - 判定游戏是否胜利。例如，地图内如果只剩下 `BoxInBoxTarget`（已经在箱子目标点的箱子）、`PlayerInPlayerTarget`（已经在玩家目标点的玩家），则判定胜利
4. 有一些方法例如重置地图状态（重新开始）等，可以尝试实现一下，如果没时间实现也不要紧，这些功能可以在前端实现

## 附录

1. 建议学习 Java 中基本的“容器类”，它们类似数组，但是会比数组有更强大的功能：

    列表容器 `List`、字典容器 `Map`

    可以在网上搜索相关资料进行学习，有时候它们可以简化编程

2. 关于常量枚举类，上课我们学的是

    ```Java
    public enum Week {
        Monday, Tuesday, Wednesday;
    }
    ```

    这样的常量枚举类定义了三个枚举常量：`Monday` `Tuesday` `Wednesday`

    每个枚举常量的类型都是 `Week` 类，所以我们可以写出类似于

    ```Java
    if (input.equals("monday")) {
        Week someday = Week.Monday;
    }
    ```

    然而这个常量类还不能实现“映射”的效果。如果像实现常量到某个数据的映射，例如星期常量到整数的映射，可以定义这么一个类：

    ```Java
    public enum Week {
        Monday(1), Tuesday(2), Wednesday(3);

        private int dayNumber;

        Week(int dayNumber) {
            this.dayNumber = dayNumber;
        }
        
        public int getDayNumber() {
            return dayNumber;
        }
    }
    ```

    这段代码实现了两件事：定义枚举常量，以及为每个枚举常量增加：
     - `dayNumber` 字段
     - 构造函数，提供一个整数 `dayNumber`，并将 `dayNumber` 字段设置为对应值
     - `getDayNumber` 方法，调用枚举常量的这个方法可以获得 `dayNumber` 字段对应值

    我们可以在代码中正常使用枚举常量，例如

    ```Java
    if (input.equals("monday")) {
        Week someday = Week.Monday;
    }

    System.out.println(someday);
    ```

    输出 `Monday`，表示枚举常量可以正常使用

    如果想把它映射成整数，可以调用它的 `dayNumber` 方法：

    ```Java
    Week day1 = Week.Monday;
    Week day2 = Week.Tuesday;

    int finalDay = day1.getDayNumber() + day2.getDayNumber();
    System.out.println(finalDay);
    ```

    输出 3，代表枚举常量已经用 `getDayNumber` 方法转换为整数
