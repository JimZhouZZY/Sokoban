# 核心逻辑设计要点

核心逻辑设计上比较复杂，因为有多个方向的判断和连锁逻辑

这里给出一些设计要求和要点：

1. 箱子**可以**连续推动，也就是玩家可以一次推动多个箱子
2. 在操作结束后，方法需要返回（给前端）一个 `List` 对象，储存了发生了位移 `A -> B` 的对象，以便前端进行动画绘制

可以说第二点是比较难的，具体可以见 `Playercore.java` 中相关的例子

---

在设计 `Playercore` 类的时候，其实可以思考一下两种方案：

1. 保存一个 `MapData` 对象在其中，通过 `getter` 和 `setter` 访问，类内直接对这个 `MapData` 对象进行逻辑操作
2. 打造为一个纯粹的工具类，每个方法都接收一个 `MapData` 对象，然后进行处理

我的看法是，第一种设计方法可能更加**便捷**，理由如下

1. 将 `MapData` 放在成员变量，省去了每一次都要向方法中传递 `MapData` 的麻烦
2. 保证了数据封装性，如果自己不管理 `MapData` ，很有可能就需要前端接手地图数据管理，这和前端的职能（显示动画、用户交互）不太相符
3. `return` 不能同时返回位移对象列表 `List` 和发生改变后的地图数据，如果再写一个类去存这两个变量也十分臃肿

因此，`Playercore` 类更适合自己管理 `MapData` 对象，所以这里对之前的代码进行一下改革 

---

## 关于位移列表细节

位移列表是所有发生移动的物体列表，这个列表将被前端获取，以对每一个绘制物体进行移动

`moveList` 这个列表保存了发生位移的坐标，对于里面的每一个字符串，具体格式为 `SubMapIndex LayerIndex X Y toX toY`

例如：

`1 0 3 5 3 6`

表示 *在子地图 1 中，在第 0 层（物体层）的物体 (3, 5) 移动到了 (3, 6)*

空气 `ObjectType.Air` 不需要加入位移列表

更多详情见 `com.sokoban.core.map` 下的 `MoveListParserDocument.md` 说明文件

---

## 关于 `PlayerCoreUtils` 细节

`PlayerCoreUtils` 是为了防止 `PlayerCore` 类太臃肿分出来的工具类

其中有一些方法，例如 `isBox` 和 `isPlayer` 等

为什么不直接使用 `obj == ObjectType.Box` 这样的代码进行判断呢？原因如下：

1. 太长
2. 如果后期加入了样式不同、但是实际上也是 `Box` 类型的地图元素，每一段代码都需要修改成 `obj == ... || obj == ...`，很不方便重构，如果用 `isBox` 方法替代，只需要修改 `isBox` 方法即可

---

*如果有任何补充，需要及时更新该文档*